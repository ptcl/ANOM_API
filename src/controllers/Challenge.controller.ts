import { Request, Response } from 'express';
import EmblemChallengeModel from '../models/EmblemChallenge.model';
import { IEmblemChallenge } from '../types/challenge';
import { validateTargetCode, validateCodeFormat, validateAccessCode, splitTargetCodeToFinalCode } from '../utils/codeValidation';
import { generateUniqueId } from '../utils/generate';

export const createChallenge = async (req: Request, res: Response) => {
    try {
        const challengeData: IEmblemChallenge = req.body;

        // Validation des champs obligatoires
        if (!challengeData.title) {
            return res.status(400).json({
                message: "Le champ title est requis."
            });
        }

        // Validation du format du code si prÃ©sent
        if (challengeData.codeFormat) {
            const formatValidation = validateCodeFormat(challengeData.codeFormat);
            if (!formatValidation.isValid) {
                return res.status(400).json({
                    message: formatValidation.message
                });
            }
        }

        // Validation du targetCode si prÃ©sent
        let autoGeneratedFinalCode = null;
        if (challengeData.targetCode) {
            const codeValidation = validateTargetCode(challengeData.targetCode);
            if (!codeValidation.isValid) {
                return res.status(400).json({
                    message: codeValidation.message
                });
            }

            // ðŸŽ¯ SPLIT AUTOMATIQUE : GÃ©nÃ©rer finalCode depuis targetCode
            try {
                autoGeneratedFinalCode = splitTargetCodeToFinalCode(challengeData.targetCode);
                console.log('ðŸ”„ Split automatique du targetCode:', {
                    targetCode: challengeData.targetCode,
                    finalCode: autoGeneratedFinalCode
                });
            } catch (error: any) {
                return res.status(400).json({
                    message: `Erreur lors du split du targetCode: ${error.message}`
                });
            }
        }

        // Validation que les challenges sont prÃ©sents et valides
        if (!challengeData.challenges || challengeData.challenges.length === 0) {
            return res.status(400).json({
                message: "Au moins un challenge doit Ãªtre fourni."
            });
        }

        // Validation des challenges individuels
        for (let i = 0; i < challengeData.challenges.length; i++) {
            const challenge = challengeData.challenges[i];

            if (!challenge.challengeType || !challenge.expectedOutput || !challenge.rewardId) {
                return res.status(400).json({
                    message: `Challenge ${i + 1}: challengeType, expectedOutput et rewardId sont requis.`
                });
            }

            // Validation des groupes
            if (!challenge.groups || challenge.groups.length === 0) {
                return res.status(400).json({
                    message: `Challenge ${i + 1}: au moins un groupe est requis.`
                });
            }

            for (let j = 0; j < challenge.groups.length; j++) {
                const group = challenge.groups[j];

                if (!group.accessCode || !group.promptLines || group.promptLines.length === 0) {
                    return res.status(400).json({
                        message: `Challenge ${i + 1}, Groupe ${j + 1}: accessCode et promptLines sont requis.`
                    });
                }

                // Validation de l'accessCode
                const accessCodeValidation = validateAccessCode(group.accessCode);
                if (!accessCodeValidation.isValid) {
                    return res.status(400).json({
                        message: `Challenge ${i + 1}, Groupe ${j + 1}: ${accessCodeValidation.message}`
                    });
                }
            }
        }

        // VÃ©rifier si un challenge avec cet emblemId existe dÃ©jÃ 
        const existingChallenge = await EmblemChallengeModel.findOne({ emblemId: challengeData.emblemId });
        if (existingChallenge) {
            return res.status(409).json({
                message: "Un challenge avec cet emblemId existe dÃ©jÃ ."
            });
        }

        // DÃ©terminer le finalCode Ã  utiliser
        let finalCodeToUse;
        if (autoGeneratedFinalCode) {
            finalCodeToUse = autoGeneratedFinalCode;
        } else if (challengeData.finalCode) {
            finalCodeToUse = challengeData.finalCode;
        } else {
            finalCodeToUse = {
                AAA: { A1: "", A2: "", A3: "" },
                BBB: { B1: "", B2: "", B3: "" },
                CCC: { C1: "", C2: "", C3: "" }
            };
        }

        const newChallenge = await EmblemChallengeModel.create({
            ...challengeData,
            emblemId: generateUniqueId('CHALL'),
            codeFormat: challengeData.codeFormat || "AAA-BBB-CCC",
            isSharedChallenge: challengeData.isSharedChallenge ?? false,
            isComplete: false,
            AgentProgress: challengeData.AgentProgress || [],
            finalCode: finalCodeToUse,
            description: challengeData.description === null ? undefined : challengeData.description
        });

        return res.status(201).json({
            message: "Challenge crÃ©Ã© avec succÃ¨s",
            challenge: newChallenge,
            ...(autoGeneratedFinalCode && {
                info: "finalCode gÃ©nÃ©rÃ© automatiquement depuis targetCode"
            })
        });

    } catch (error: any) {
        console.error('Erreur lors de la crÃ©ation du challenge:', error);

        // Gestion des erreurs de validation Mongoose
        if (error.name === 'ValidationError') {
            return res.status(400).json({
                message: "Erreur de validation",
                details: error.message
            });
        }

        // Gestion des erreurs de duplication (unique constraint)
        if (error.code === 11000) {
            return res.status(409).json({
                message: "Un challenge avec cet emblemId existe dÃ©jÃ ."
            });
        }

        return res.status(500).json({
            message: "Erreur interne du serveur lors de la crÃ©ation du challenge",
            error: process.env.NODE_ENV === 'development' ? error.message : undefined
        });
    }
};