import { Request, Response } from 'express';
import { IEmblemChallenge } from '../types/challenge';
import { generateUniqueId } from '../utils/generate';
import { determineFinalCode, splitTargetCodeToFinalCode, validateAndProcessChallenges, validateCodeFormat, validateTargetCode } from '../utils/codevalidation';
import EmblemChallengeModel from '../models/challenge.model';

export const createChallenge = async (req: Request, res: Response) => {
    try {
        const challengeData: IEmblemChallenge = req.body;

        // ✅ Validations de base
        if (!challengeData.title) {
            return res.status(400).json({ message: "Le champ title est requis." });
        }

        if (challengeData.codeFormat) {
            const formatValidation = validateCodeFormat(challengeData.codeFormat);
            if (!formatValidation.isValid) {
                return res.status(400).json({ message: formatValidation.message });
            }
        }

        let autoGeneratedFinalCode = null;
        if (challengeData.targetCode) {
            const codeValidation = validateTargetCode(challengeData.targetCode);
            if (!codeValidation.isValid) {
                return res.status(400).json({ message: codeValidation.message });
            }

            try {
                autoGeneratedFinalCode = splitTargetCodeToFinalCode(challengeData.targetCode);
            } catch (error: any) {
                return res.status(400).json({
                    message: `Erreur lors du split du targetCode: ${error.message}`
                });
            }
        }

        if (!challengeData.challenges?.length) {
            return res.status(400).json({ message: "Au moins un challenge doit être fourni." });
        }

        const validationError = validateAndProcessChallenges(challengeData.challenges);
        if (validationError) {
            return res.status(400).json({ message: validationError });
        }

        // ✅ Vérification d'unicité de l'emblemId
        if (challengeData.emblemId) {
            const existingChallenge = await EmblemChallengeModel.findOne({ emblemId: challengeData.emblemId });
            if (existingChallenge) {
                return res.status(409).json({ message: "Un challenge avec cet emblemId existe déjà." });
            }
        }

        const newChallenge = await EmblemChallengeModel.create({
            ...challengeData,
            emblemId: challengeData.emblemId || generateUniqueId('CHALL'),
            codeFormat: challengeData.codeFormat || "AAA-BBB-CCC",
            isSharedChallenge: challengeData.isSharedChallenge ?? false,
            isComplete: false,
            AgentProgress: challengeData.AgentProgress || [],
            finalCode: determineFinalCode(autoGeneratedFinalCode, challengeData.finalCode),
            description: challengeData.description === null ? undefined : challengeData.description
        });

        return res.status(201).json({
            message: "Challenge créé avec succès",
            challenge: newChallenge,
            ...(autoGeneratedFinalCode && { info: "finalCode généré automatiquement depuis targetCode" })
        });

    } catch (error: any) {
        return res.status(500).json({
            message: "Erreur lors de la création du challenge",
            error: error.message || "Une erreur inconnue est survenue"
        });
    }
};
