import { Request, Response } from 'express';
import { IEmblemChallenge } from '../types/challenge';
import { generateUniqueId } from '../utils/generate';
import { determineFinalCode, getFragmentsData, getPartialCode, splitTargetCodeToFinalCode, validateAndProcessChallenges, validateCodeFormat, validateTargetCode } from '../utils/codevalidation';
import { ChallengeModel } from '../models/challenge.model';
import { AgentModel } from '../models/agent.model';
import { formatForUser } from '../utils';

export const createChallenge = async (req: Request, res: Response) => {
    try {
        const challengeData: IEmblemChallenge = req.body;

        if (!challengeData.title) {
            return res.status(400).json({ message: "Le champ title est requis." });
        }

        if (challengeData.codeFormat) {
            const formatValidation = validateCodeFormat(challengeData.codeFormat);
            if (!formatValidation.isValid) {
                return res.status(400).json({ message: formatValidation.message });
            }
        }

        let autoGeneratedFinalCode = null;
        if (challengeData.targetCode) {
            const codeValidation = validateTargetCode(challengeData.targetCode);
            if (!codeValidation.isValid) {
                return res.status(400).json({ message: codeValidation.message });
            }

            try {
                autoGeneratedFinalCode = splitTargetCodeToFinalCode(challengeData.targetCode);
            } catch (error: any) {
                return res.status(400).json({
                    message: `Erreur lors du split du targetCode: ${error.message}`
                });
            }
        }

        if (!challengeData.challenges?.length) {
            return res.status(400).json({ message: "Au moins un challenge doit être fourni." });
        }

        const validationError = validateAndProcessChallenges(challengeData.challenges);
        if (validationError) {
            return res.status(400).json({ message: validationError });
        }

        if (challengeData.challengeId) {
            const existingChallenge = await ChallengeModel.findOne({ challengeId: challengeData.challengeId });
            if (existingChallenge) {
                return res.status(409).json({ message: "Un challenge avec cet challengeId existe déjà." });
            }
        }

        for (const [i, challengeItem] of challengeData.challenges.entries()) {
            if (
                !challengeItem.fragmentId ||
                !Array.isArray(challengeItem.fragmentId) ||
                challengeItem.fragmentId.length === 0
            ) {
                return res.status(400).json({
                    message: `Le champ fragmentId est requis et doit être un tableau non vide pour le challenge ${i + 1}. Indique la ou les récompenses à débloquer (ex: ["A1"], ["B2"], ["C3"]).`
                });
            }
            const validFragments = [
                "A1", "A2", "A3",
                "B1", "B2", "B3",
                "C1", "C2", "C3"
            ];
            for (const frag of challengeItem.fragmentId) {
                if (!validFragments.includes(frag)) {
                    return res.status(400).json({
                        message: `fragmentId "${frag}" invalide pour le challenge ${i + 1}. Utilise uniquement A1, A2, A3, B1, B2, B3, C1, C2, C3.`
                    });
                }
            }
        }

        const newChallenge = await ChallengeModel.create({
            ...challengeData,
            challengeId: challengeData.challengeId || generateUniqueId('CHALL'),
            codeFormat: challengeData.codeFormat || "AAA-BBB-CCC",
            isSharedChallenge: challengeData.isSharedChallenge ?? false,
            isComplete: false,
            isCompleteBy: null, // Ajout du champ isCompleteBy
            isActive: challengeData.isActive ?? true, // Ajout du champ isActive avec valeur par défaut
            AgentProgress: challengeData.AgentProgress || [],
            finalCode: determineFinalCode(autoGeneratedFinalCode, challengeData.finalCode),
            description: challengeData.description === null ? undefined : challengeData.description
        });

        return res.status(201).json({
            message: "Challenge créé avec succès",
            challenge: newChallenge,
            ...(autoGeneratedFinalCode && { info: "finalCode généré automatiquement depuis targetCode" })
        });

    } catch (error: any) {
        return res.status(500).json({
            message: "Erreur lors de la création du challenge",
            error: error.message || "Une erreur inconnue est survenue"
        });
    }
};

export const getChallengeById = async (req: Request, res: Response) => {
    try {
        const { challengeId } = req.params;
        if (!challengeId) {
            return res.status(400).json({ message: "challengeId requis" });
        }
        const challenge = await ChallengeModel.findOne({ challengeId });
        if (!challenge) {
            return res.status(404).json({ message: "Challenge non trouvé" });
        }
        return res.json({ success: true, challenge });
    } catch (error: any) {
        return res.status(500).json({ message: "Erreur lors de la récupération", error: error.message });
    }
};

export const getAllChallenges = async (req: Request, res: Response) => {
    try {
        const challenges = await ChallengeModel.find().lean();
        return res.json({
            success: true,
            challenges,
            count: challenges.length
        });
    } catch (error: any) {
        return res.status(500).json({
            success: false,
            message: "Erreur lors de la récupération des challenges",
            error: error.message
        });
    }
};

export const getAvailableChallenges = async (req: Request, res: Response) => {
    try {
        // Récupérer uniquement les challenges publics et actifs
        const challenges = await ChallengeModel
            .find({
                isActive: true,
                isComplete: false,
                // Optionnel: ajouter un champ isPublic si nécessaire
                // isPublic: { $ne: false }
            })
            .select('challengeId title description difficulty category createdAt')
            .lean();

        // Formater les données pour l'affichage public
        const formattedChallenges = challenges.map(challenge => ({
            challengeId: challenge.challengeId,
            title: challenge.title,
            description: challenge.description,
            difficulty: challenge.difficulty || 'UNKNOWN',
            category: challenge.category || 'GENERAL',
            createdAt: challenge.createdAt
        }));

        return res.json({
            success: true,
            data: {
                challenges: formattedChallenges,
                count: formattedChallenges.length
            },
            message: 'Available challenges retrieved successfully'
        });
    } catch (error: any) {
        // Log sécurisé sans exposer d'informations sensibles
        console.error('Public challenges fetch error:', {
            timestamp: formatForUser(),
            ip: req.ip,
            userAgent: req.get('User-Agent')
        });

        return res.status(500).json({
            success: false,
            error: 'Internal server error'
        });
    }
};

export const updateChallenge = async (req: Request, res: Response) => {
    try {
        const { challengeId } = req.params;
        if (!challengeId) {
            return res.status(400).json({ message: "challengeId requis" });
        }
        const updateData = req.body;
        const updated = await ChallengeModel.findOneAndUpdate(
            { challengeId },
            updateData,
            { new: true }
        );
        if (!updated) {
            return res.status(404).json({ message: "Challenge non trouvé" });
        }
        return res.json({ success: true, challenge: updated });
    } catch (error: any) {
        return res.status(500).json({ message: "Erreur lors de la mise à jour", error: error.message });
    }
};

export const deleteChallenge = async (req: Request, res: Response) => {
    try {
        const { challengeId } = req.params;
        if (!challengeId) {
            return res.status(400).json({ message: "challengeId requis" });
        }
        const deleted = await ChallengeModel.findOneAndDelete({ challengeId });
        if (!deleted) {
            return res.status(404).json({ message: "Challenge non trouvé" });
        }
        return res.json({ success: true, message: "Challenge supprimé" });
    } catch (error: any) {
        return res.status(500).json({ message: "Erreur lors de la suppression", error: error.message });
    }
};

export const accessChallenge = async (req: Request, res: Response) => {
    try {
        const { accessCode } = req.body;
        const agentBungieId = req.user?.bungieId;

        if (!accessCode) {
            return res.status(400).json({
                success: false,
                message: "Code d'accès requis"
            });
        }

        if (!agentBungieId) {
            return res.status(401).json({
                success: false,
                message: "Agent non authentifié"
            });
        }

        const agent = await AgentModel.findOne({ bungieId: agentBungieId });
        if (!agent) {
            return res.status(404).json({
                success: false,
                message: "Agent non trouvé"
            });
        }

        const challenge = await ChallengeModel.findOne({
            "challenges.groups.accessCode": accessCode
        });

        if (!challenge) {
            return res.status(404).json({
                success: false,
                message: "Code d'accès invalide"
            });
        }

        // Vérification si le challenge est actif
        if (!challenge.isActive) {
            return res.status(403).json({
                success: false,
                message: "Ce challenge n'est pas actif actuellement."
            });
        }

        // Vérification si le challenge est complété
        if (challenge.isComplete) {
            const completedBy = challenge.isCompleteBy
                ? await AgentModel.findOne({ bungieId: challenge.isCompleteBy }).select('protocol.agentName bungieUser.displayName')
                : null;

            const completedByName = completedBy
                ? (completedBy.protocol?.agentName || completedBy.bungieUser?.displayName || "Agent inconnu")
                : "Agent inconnu";

            return res.status(403).json({
                success: false,
                message: `Ce challenge a été complété par ${completedByName} et n'est plus disponible.`,
                isComplete: true,
                completedBy: completedByName
            });
        }

        const existingAgentProgress = challenge.AgentProgress.find((agentProgress: any) =>
            agentProgress.bungieId === agentBungieId
        );

        if (existingAgentProgress) {
            let currentChallengeData = null;
            let currentGroup = null;

            for (const challengeItem of challenge.challenges) {
                const group = challengeItem.groups.find((g: { accessCode: string }) => g.accessCode === accessCode);
                if (group) {
                    currentChallengeData = challengeItem;
                    currentGroup = group;
                    existingAgentProgress.currentProgress = accessCode;
                    challenge.markModified('AgentProgress');
                    await challenge.save();
                    break;
                }
            }
            await challenge.save();

            const fragmentsData = getFragmentsData(existingAgentProgress.unlockedFragments, challenge.finalCode);
            return res.status(200).json({
                success: true,
                message: "Agent déjà enregistré pour ce défi",
                data: {
                    challengeId: challenge.challengeId,
                    title: challenge.title,
                    description: challenge.description,
                    currentChallenge: {
                        challengeType: currentChallengeData?.challengeType,
                        promptLines: currentGroup?.promptLines,
                        hintLines: currentChallengeData?.hintLines
                    },
                    agentProgress: existingAgentProgress,
                    fragmentsData
                }
            });
        }

        let targetChallengeData = null;
        let targetGroup = null;

        for (const challengeItem of challenge.challenges) {
            const group = challengeItem.groups.find((g: { accessCode: string }) => g.accessCode === accessCode);
            if (group) {
                targetChallengeData = challengeItem;
                targetGroup = group;
                break;
            }
        }

        const newAgentProgress = {
            agentId: agent._id,
            bungieId: agentBungieId,
            displayName: agent.protocol.agentName || agent.bungieUser.displayName || "Agent",
            unlockedFragments: [] as string[],
            currentProgress: accessCode,
            complete: false,
            lastUpdated: new Date()
        };

        challenge.AgentProgress.push(newAgentProgress);
        const partialCode = getPartialCode(newAgentProgress.unlockedFragments, challenge.finalCode);

        const existingChallengeInAgent = agent.challenges.find((c: { challengeId: string }) => c.challengeId === challenge.challengeId);
        if (!existingChallengeInAgent) {
            agent.challenges.push({
                challengeMongoId: challenge._id,
                challengeId: challenge.challengeId,
                title: challenge.title,
                complete: false,
                accessedAt: new Date(),
                partialCode,
                unlockedFragments: [],
                progress: newAgentProgress
            });
        } else {
            existingChallengeInAgent.accessedAt = new Date();
            existingChallengeInAgent.partialCode = partialCode;
            existingChallengeInAgent.unlockedFragments = newAgentProgress.unlockedFragments;
            existingChallengeInAgent.progress = newAgentProgress;
        }
        agent.lastActivity = new Date();
        await agent.save();

        await challenge.save();

        return res.status(200).json({
            success: true,
            message: "Accès au défi accordé avec succès",
            data: {
                challengeId: challenge.challengeId,
                title: challenge.title,
                description: challenge.description,
                codeFormat: challenge.codeFormat,
                currentChallenge: {
                    challengeType: targetChallengeData?.challengeType,
                    promptLines: targetGroup?.promptLines,
                    hintLines: targetChallengeData?.hintLines
                },
                agentProgress: newAgentProgress
            }
        });

    } catch (error: any) {
        console.error("Erreur lors de l'accès au défi:", error);
        return res.status(500).json({
            success: false,
            message: "Erreur serveur lors de l'accès au défi",
            error: process.env.NODE_ENV === 'development' ? error.message : undefined
        });
    }
};

export const submitChallengeAnswer = async (req: Request, res: Response) => {
    try {
        const { challengeId, answer } = req.body;
        const agentBungieId = req.user?.bungieId;

        if (!challengeId || !answer) {
            return res.status(400).json({
                success: false,
                message: "challengeId et answer sont requis"
            });
        }

        if (!agentBungieId) {
            return res.status(401).json({
                success: false,
                message: "Agent non authentifié"
            });
        }

        const challenge = await ChallengeModel.findOne({ challengeId });
        if (!challenge) {
            return res.status(404).json({
                success: false,
                message: "Défi non trouvé"
            });
        }

        // Vérification si le challenge est actif
        if (!challenge.isActive) {
            return res.status(403).json({
                success: false,
                message: "Ce challenge n'est pas actif actuellement."
            });
        }

        // Vérification si le challenge est déjà complété
        if (challenge.isComplete) {
            const completedBy = challenge.isCompleteBy
                ? await AgentModel.findOne({ bungieId: challenge.isCompleteBy }).select('protocol.agentName bungieUser.displayName')
                : null;

            const completedByName = completedBy
                ? (completedBy.protocol?.agentName || completedBy.bungieUser?.displayName || "Agent inconnu")
                : "Agent inconnu";

            return res.status(403).json({
                success: false,
                message: `Ce challenge a été complété par ${completedByName} et n'est plus disponible.`,
                isComplete: true,
                completedBy: completedByName
            });
        }

        const agentProgress = challenge.AgentProgress.find((agent: any) =>
            agent.bungieId === agentBungieId
        );

        if (!agentProgress) {
            return res.status(403).json({
                success: false,
                message: "Accès non autorisé - utilisez d'abord un code d'accès"
            });
        }

        // Vérification si cet agent a déjà complété le challenge
        if (agentProgress.complete) {
            return res.status(403).json({
                success: false,
                message: "Vous avez déjà complété ce challenge.",
                isComplete: true
            });
        }

        let currentChallenge = null;
        for (const challengeItem of challenge.challenges) {
            const hasAccess = challengeItem.groups.some((group: { accessCode: string }) =>
                group.accessCode === agentProgress.currentProgress
            );
            if (hasAccess) {
                currentChallenge = challengeItem;
                break;
            }
        }

        if (!currentChallenge) {
            return res.status(400).json({
                success: false,
                message: "Aucune énigme active trouvée pour cet agent"
            });
        }

        const normalizedAnswer = answer.toLowerCase().trim();
        const normalizedExpected = currentChallenge.expectedOutput.toLowerCase().trim();
        const isCorrect = normalizedAnswer === normalizedExpected;

        if (isCorrect) {
            for (const frag of currentChallenge.fragmentId) {
                if (!agentProgress.unlockedFragments.includes(frag)) {
                    agentProgress.unlockedFragments.push(frag);
                }
            }

            agentProgress.lastUpdated = new Date();

            const totalFragments = challenge.challenges.flatMap((c: any) => c.fragmentId);
            const hasAllFragments = totalFragments.every((frag: string) =>
                agentProgress.unlockedFragments.includes(frag)
            );

            if (hasAllFragments) {
                agentProgress.complete = true;
                challenge.isComplete = true;
                challenge.isCompleteBy = agentBungieId;
            }

            await challenge.save();

            const agent = await AgentModel.findOne({ bungieId: agentBungieId });
            if (agent) {
                const existingChallengeInAgent = agent.challenges.find((c: { challengeId: string }) => c.challengeId === challenge.challengeId);
                if (existingChallengeInAgent) {
                    const partialCode = getPartialCode(agentProgress.unlockedFragments, challenge.finalCode);
                    existingChallengeInAgent.complete = agentProgress.complete;
                    existingChallengeInAgent.partialCode = partialCode;
                    existingChallengeInAgent.unlockedFragments = agentProgress.unlockedFragments;
                    existingChallengeInAgent.progress = agentProgress;
                }
                agent.lastActivity = new Date();
                await agent.save();
            }

            const fragmentsData = getFragmentsData(currentChallenge.fragmentId, challenge.finalCode);

            return res.status(200).json({
                success: true,
                message: hasAllFragments
                    ? "Félicitations ! Vous avez complété tout le challenge !"
                    : "Réponse correcte ! Fragment débloqué.",
                data: {
                    fragments: currentChallenge.fragmentId,
                    fragmentsData,
                    unlockedFragments: agentProgress.unlockedFragments,
                    isComplete: agentProgress.complete,
                    totalFragments: agentProgress.unlockedFragments.length,
                    maxFragments: totalFragments.length,
                    ...(hasAllFragments && {
                        congratulations: "Challenge complété avec succès !",
                        completedBy: agentBungieId
                    })
                }
            });
        } else {
            return res.status(400).json({
                success: false,
                message: "Réponse incorrecte",
            });
        }

    } catch (error: any) {
        console.error("Erreur lors de la soumission de la réponse:", error);
        return res.status(500).json({
            success: false,
            message: "Erreur serveur lors de la soumission",
            error: process.env.NODE_ENV === 'development' ? error.message : undefined
        });
    }
};
export const getAgentProgress = async (req: Request, res: Response) => {
    try {
        const agentBungieId = req.user?.bungieId;
        if (!agentBungieId) {
            return res.status(401).json({
                success: false,
                message: "Agent non authentifié"
            });
        }

        // Compter le nombre total de challenges où l'agent apparaît
        const totalChallenges = await ChallengeModel.countDocuments({
            "AgentProgress.bungieId": agentBungieId
        });

        // Optionnel : récupérer les détails si besoin
        const challenges = await ChallengeModel.find({
            "AgentProgress.bungieId": agentBungieId
        }).select('challengeId title description AgentProgress finalCode isComplete isCompleteBy isActive');

        const agentChallenges = challenges.map(challenge => {
            const agentProgress = challenge.AgentProgress.find((agent: any) =>
                agent.bungieId === agentBungieId
            );

            const partialCode = getPartialCode(agentProgress.unlockedFragments, challenge.finalCode);

            return {
                challengeId: challenge.challengeId,
                title: challenge.title,
                description: challenge.description,
                progress: agentProgress,
                partialCode,
                isComplete: challenge.isComplete,
                isCompleteBy: challenge.isCompleteBy,
                isActive: challenge.isActive
            };
        });

        return res.status(200).json({
            success: true,
            total: totalChallenges, // ← Le nombre total
            data: agentChallenges
        });
    } catch (error: any) {
        console.error("Erreur lors de la récupération du progrès:", error);
        return res.status(500).json({
            success: false,
            message: "Erreur serveur lors de la récupération du progrès",
            error: process.env.NODE_ENV === 'development' ? error.message : undefined
        });
    }
};

export const getAgentChallengeFragments = async (req: Request, res: Response) => {
    try {
        const { challengeId } = req.params;
        const agentBungieId = req.user?.bungieId;

        if (!challengeId) {
            return res.status(400).json({ message: "challengeId requis" });
        }
        if (!agentBungieId) {
            return res.status(401).json({ message: "Agent non authentifié" });
        }

        const challenge = await ChallengeModel.findOne({ challengeId });
        if (!challenge) {
            return res.status(404).json({ message: "Challenge non trouvé" });
        }

        const agentProgress = challenge.AgentProgress.find((agent: any) =>
            agent.bungieId === agentBungieId
        );
        if (!agentProgress) {
            return res.status(404).json({ message: "Progression non trouvée pour cet agent" });
        }

        const fragmentsData = getFragmentsData(agentProgress.unlockedFragments, challenge.finalCode);

        return res.status(200).json({
            success: true,
            challengeId,
            unlockedFragments: agentProgress.unlockedFragments,
            fragmentsData,
            isComplete: challenge.isComplete,
            isCompleteBy: challenge.isCompleteBy,
            isActive: challenge.isActive
        });
    } catch (error: any) {
        return res.status(500).json({
            success: false,
            message: "Erreur serveur lors de la récupération des fragments",
            error: error.message
        });
    }
};