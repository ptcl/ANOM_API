import { Request, Response } from 'express';
import { IEmblemChallenge } from '../types/challenge';
import { generateUniqueId } from '../utils/generate';
import { determineFinalCode, getFragmentsData, getPartialCode, splitTargetCodeToFinalCode, validateAndProcessChallenges, validateCodeFormat, validateTargetCode } from '../utils/codevalidation';
import { ChallengeModel } from '../models/challenge.model';
import { Agent } from '../models/agent.model';
import { formatForUser } from '../utils';
import { agentStatsService } from '../services/agentStats';

export const createChallenge = async (req: Request, res: Response) => {
    try {
        const challengeData: IEmblemChallenge = req.body;

        if (!challengeData.title) {
            return res.status(400).json({ message: "Le champ title est requis." });
        }

        if (challengeData.codeFormat) {
            const formatValidation = validateCodeFormat(challengeData.codeFormat);
            if (!formatValidation.isValid) {
                return res.status(400).json({ message: formatValidation.message });
            }
        }

        let autoGeneratedFinalCode = null;
        if (challengeData.targetCode) {
            const codeValidation = validateTargetCode(challengeData.targetCode);
            if (!codeValidation.isValid) {
                return res.status(400).json({ message: codeValidation.message });
            }

            try {
                autoGeneratedFinalCode = splitTargetCodeToFinalCode(challengeData.targetCode);
            } catch (error: any) {
                return res.status(400).json({
                    message: `Erreur lors du split du targetCode: ${error.message}`
                });
            }
        }

        if (!challengeData.challenges?.length) {
            return res.status(400).json({ message: "Au moins un challenge doit √™tre fourni." });
        }

        const validationError = validateAndProcessChallenges(challengeData.challenges);
        if (validationError) {
            return res.status(400).json({ message: validationError });
        }

        if (challengeData.challengeId) {
            const existingChallenge = await ChallengeModel.findOne({ challengeId: challengeData.challengeId });
            if (existingChallenge) {
                return res.status(409).json({ message: "Un challenge avec cet challengeId existe d√©j√†." });
            }
        }

        for (const [i, challengeItem] of challengeData.challenges.entries()) {
            if (
                !challengeItem.fragmentId ||
                !Array.isArray(challengeItem.fragmentId) ||
                challengeItem.fragmentId.length === 0
            ) {
                return res.status(400).json({
                    message: `Le champ fragmentId est requis et doit √™tre un tableau non vide pour le challenge ${i + 1}. Indique la ou les r√©compenses √† d√©bloquer (ex: ["A1"], ["B2"], ["C3"]).`
                });
            }
            const validFragments = [
                "A1", "A2", "A3",
                "B1", "B2", "B3",
                "C1", "C2", "C3"
            ];
            for (const frag of challengeItem.fragmentId) {
                if (!validFragments.includes(frag)) {
                    return res.status(400).json({
                        message: `fragmentId "${frag}" invalide pour le challenge ${i + 1}. Utilise uniquement A1, A2, A3, B1, B2, B3, C1, C2, C3.`
                    });
                }
            }
        }

        const newChallenge = await ChallengeModel.create({
            ...challengeData,
            challengeId: challengeData.challengeId || generateUniqueId('CHALL'),
            codeFormat: challengeData.codeFormat || "AAA-BBB-CCC",
            isSharedChallenge: challengeData.isSharedChallenge ?? false,
            isComplete: false,
            isCompleteBy: null, // Ajout du champ isCompleteBy
            isActive: challengeData.isActive ?? true, // Ajout du champ isActive avec valeur par d√©faut
            AgentProgress: challengeData.AgentProgress || [],
            finalCode: determineFinalCode(autoGeneratedFinalCode, challengeData.finalCode),
            description: challengeData.description === null ? undefined : challengeData.description
        });

        return res.status(201).json({
            message: "Challenge cr√©√© avec succ√®s",
            challenge: newChallenge,
            ...(autoGeneratedFinalCode && { info: "finalCode g√©n√©r√© automatiquement depuis targetCode" })
        });

    } catch (error: any) {
        return res.status(500).json({
            message: "Erreur lors de la cr√©ation du challenge",
            error: error.message || "Une erreur inconnue est survenue"
        });
    }
};

export const getChallengeById = async (req: Request, res: Response) => {
    try {
        const { challengeId } = req.params;
        if (!challengeId) {
            return res.status(400).json({ message: "challengeId requis" });
        }
        const challenge = await ChallengeModel.findOne({ challengeId });
        if (!challenge) {
            return res.status(404).json({ message: "Challenge non trouv√©" });
        }
        return res.json({ success: true, challenge });
    } catch (error: any) {
        return res.status(500).json({ message: "Erreur lors de la r√©cup√©ration", error: error.message });
    }
};

export const getAllChallenges = async (req: Request, res: Response) => {
    try {
        const challenges = await ChallengeModel.find().lean();
        return res.json({
            success: true,
            challenges,
            count: challenges.length
        });
    } catch (error: any) {
        return res.status(500).json({
            success: false,
            message: "Erreur lors de la r√©cup√©ration des challenges",
            error: error.message
        });
    }
};

export const getAvailableChallenges = async (req: Request, res: Response) => {
    try {
        // R√©cup√©rer uniquement les challenges publics et actifs
        const challenges = await ChallengeModel
            .find({
                isActive: true,
                isComplete: false,
                // Optionnel: ajouter un champ isPublic si n√©cessaire
                // isPublic: { $ne: false }
            })
            .select('challengeId title description difficulty category createdAt')
            .lean();

        // Formater les donn√©es pour l'affichage public
        const formattedChallenges = challenges.map(challenge => ({
            challengeId: challenge.challengeId,
            title: challenge.title,
            description: challenge.description,
            difficulty: challenge.difficulty || 'UNKNOWN',
            category: challenge.category || 'GENERAL',
            createdAt: challenge.createdAt
        }));

        return res.json({
            success: true,
            data: {
                challenges: formattedChallenges,
                count: formattedChallenges.length
            },
            message: 'Available challenges retrieved successfully'
        });
    } catch (error: any) {
        // Log s√©curis√© sans exposer d'informations sensibles
        console.error('Public challenges fetch error:', {
            timestamp: formatForUser(),
            ip: req.ip,
            userAgent: req.get('User-Agent')
        });

        return res.status(500).json({
            success: false,
            error: 'Internal server error'
        });
    }
};

export const updateChallenge = async (req: Request, res: Response) => {
    try {
        const { challengeId } = req.params;
        if (!challengeId) {
            return res.status(400).json({ message: "challengeId requis" });
        }
        const updateData = req.body;
        const updated = await ChallengeModel.findOneAndUpdate(
            { challengeId },
            updateData,
            { new: true }
        );
        if (!updated) {
            return res.status(404).json({ message: "Challenge non trouv√©" });
        }
        return res.json({ success: true, challenge: updated });
    } catch (error: any) {
        return res.status(500).json({ message: "Erreur lors de la mise √† jour", error: error.message });
    }
};

export const deleteChallenge = async (req: Request, res: Response) => {
    try {
        const { challengeId } = req.params;
        if (!challengeId) {
            return res.status(400).json({ message: "challengeId requis" });
        }
        const deleted = await ChallengeModel.findOneAndDelete({ challengeId });
        if (!deleted) {
            return res.status(404).json({ message: "Challenge non trouv√©" });
        }
        return res.json({ success: true, message: "Challenge supprim√©" });
    } catch (error: any) {
        return res.status(500).json({ message: "Erreur lors de la suppression", error: error.message });
    }
};
export const accessChallenge = async (req: Request, res: Response) => {
    try {
        const { accessCode } = req.body;
        const agentBungieId = req.user?.bungieId;

        if (!accessCode) return res.status(400).json({ success: false, message: "Code d'acc√®s requis" });
        if (!agentBungieId) return res.status(401).json({ success: false, message: "Agent non authentifi√©" });

        const agent = await Agent.findOne({ bungieId: agentBungieId });
        if (!agent) return res.status(404).json({ success: false, message: "Agent non trouv√©" });

        const challenge = await ChallengeModel.findOne({ "challenges.groups.accessCode": accessCode });
        if (!challenge) return res.status(404).json({ success: false, message: "Code d'acc√®s invalide" });
        if (!challenge.isActive) return res.status(403).json({ success: false, message: "Ce challenge n'est pas actif actuellement." });

        if (challenge.isComplete) {
            const completedBy = challenge.isCompleteBy
                ? await Agent.findOne({ bungieId: challenge.isCompleteBy }).select("protocol.agentName bungieUser.displayName")
                : null;

            const completedByName = completedBy?.protocol?.agentName || completedBy?.bungieUser?.displayName || "Agent inconnu";
            return res.status(403).json({
                success: false,
                message: `Ce challenge a √©t√© compl√©t√© par ${completedByName} et n'est plus disponible.`,
                isComplete: true,
                completedBy: completedByName
            });
        }

        // üîé sous-challenge cibl√© par l'accessCode
        const targetChallenge = challenge.challenges.find((c: any) =>
            c.groups?.some((g: any) => g.accessCode === accessCode)
        );
        if (!targetChallenge) {
            return res.status(404).json({ success: false, message: "Aucun challenge associ√© √† ce code." });
        }

        // ‚úÖ rewardId vient du sous-challenge (fallback √©ventuel au root)
        const rewardId: string | undefined = targetChallenge.rewardId || (challenge as any).rewardId;
        if (!rewardId) {
            return res.status(500).json({
                success: false,
                message: "Configuration invalide : rewardId manquant sur le challenge cibl√©."
            });
        }

        // Progress existante ?
        const existingProgress = challenge.AgentProgress.find((ap: any) => ap.bungieId === agentBungieId);
        const now = new Date();

        if (existingProgress) {
            existingProgress.currentProgress = accessCode;
            existingProgress.lastUpdated = now;
            challenge.markModified("AgentProgress");
            await challenge.save();

            const fragmentsData = getFragmentsData(existingProgress.unlockedFragments, challenge.finalCode);
            return res.status(200).json({
                success: true,
                message: "Agent d√©j√† enregistr√© pour ce d√©fi",
                data: {
                    challengeId: challenge.challengeId,
                    title: challenge.title,
                    description: challenge.description,
                    currentChallenge: {
                        challengeType: targetChallenge.challengeType,
                        promptLines: targetChallenge.groups.find((g: any) => g.accessCode === accessCode)?.promptLines,
                        hintLines: targetChallenge.hintLines
                    },
                    agentProgress: existingProgress,
                    fragmentsData
                }
            });
        }

        // ‚ûï cr√©ation de la progression c√¥t√© Challenge
        const newProgress = {
            agentId: agent._id,
            bungieId: agentBungieId,
            displayName: agent.protocol?.agentName || agent.bungieUser?.displayName || "Agent",
            unlockedFragments: [] as string[],
            currentProgress: accessCode,
            complete: false,
            lastUpdated: now
        };
        challenge.AgentProgress.push(newProgress);
        await challenge.save();

        // üßÆ total de fragments du challenge (unique)
        const allFragments = Array.from(new Set(challenge.challenges.flatMap((c: any) => c.fragmentId)));
        const totalFragments = allFragments.length;

        // üîó enregistrement c√¥t√© Agent (challenge + emblem)
        const agentChallenge = agent.challenges.find((c: any) => c.challengeId === challenge.challengeId);
        if (!agentChallenge) {
            agent.challenges.push({
                challengeMongoId: challenge._id,
                challengeId: challenge.challengeId,
                title: challenge.title,
                accessedAt: now,
                lastUpdatedAt: now,
                emblems: [
                    {
                        emblemId: rewardId,            // ‚úÖ ici corrig√©
                        totalFragments,
                        unlockedFragments: [],
                        isComplete: false
                    }
                ]
            });
        } else {
            agentChallenge.accessedAt = now;
            agentChallenge.lastUpdatedAt = now;

            const existingEmblem = agentChallenge.emblems.find((e: any) => e.emblemId === rewardId);
            if (!existingEmblem) {
                agentChallenge.emblems.push({
                    emblemId: rewardId,            // ‚úÖ ici corrig√© aussi
                    totalFragments,
                    unlockedFragments: [],
                    isComplete: false
                });
            }
        }

        agent.lastActivity = now;
        await agent.save();

        // Option : sync des stats globales
        // await agentStatsService.syncAgentStats(agent._id);

        return res.status(200).json({
            success: true,
            message: "Acc√®s au d√©fi accord√© avec succ√®s",
            data: {
                challengeId: challenge.challengeId,
                title: challenge.title,
                description: challenge.description,
                codeFormat: challenge.codeFormat,
                currentChallenge: {
                    challengeType: targetChallenge.challengeType,
                    promptLines: targetChallenge.groups.find((g: any) => g.accessCode === accessCode)?.promptLines,
                    hintLines: targetChallenge.hintLines
                },
                agentProgress: newProgress
            }
        });
    } catch (error: any) {
        console.error("Erreur lors de l'acc√®s au d√©fi:", error);
        return res.status(500).json({
            success: false,
            message: "Erreur serveur lors de l'acc√®s au d√©fi",
            error: process.env.NODE_ENV === "development" ? error.message : undefined
        });
    }
};
export const submitChallengeAnswer = async (req: Request, res: Response) => {
    try {
        const { challengeId, answer } = req.body;
        const agentBungieId = req.user?.bungieId;

        if (!challengeId || !answer) {
            return res.status(400).json({
                success: false,
                message: "challengeId et answer sont requis"
            });
        }

        if (!agentBungieId) {
            return res.status(401).json({
                success: false,
                message: "Agent non authentifi√©"
            });
        }

        const challenge = await ChallengeModel.findOne({ challengeId });
        if (!challenge) {
            return res.status(404).json({
                success: false,
                message: "D√©fi non trouv√©"
            });
        }

        // V√©rification si le challenge est actif
        if (!challenge.isActive) {
            return res.status(403).json({
                success: false,
                message: "Ce challenge n'est pas actif actuellement."
            });
        }

        // V√©rification si le challenge est d√©j√† compl√©t√©
        if (challenge.isComplete) {
            const completedBy = challenge.isCompleteBy
                ? await Agent.findOne({ bungieId: challenge.isCompleteBy }).select('protocol.agentName bungieUser.displayName')
                : null;

            const completedByName = completedBy
                ? (completedBy.protocol?.agentName || completedBy.bungieUser?.displayName || "Agent inconnu")
                : "Agent inconnu";

            return res.status(403).json({
                success: false,
                message: `Ce challenge a √©t√© compl√©t√© par ${completedByName} et n'est plus disponible.`,
                isComplete: true,
                completedBy: completedByName
            });
        }

        const agentProgress = challenge.AgentProgress.find((agent: any) =>
            agent.bungieId === agentBungieId
        );

        if (!agentProgress) {
            return res.status(403).json({
                success: false,
                message: "Acc√®s non autoris√© - utilisez d'abord un code d'acc√®s"
            });
        }

        // V√©rification si cet agent a d√©j√† compl√©t√© le challenge
        if (agentProgress.complete) {
            return res.status(403).json({
                success: false,
                message: "Vous avez d√©j√† compl√©t√© ce challenge.",
                isComplete: true
            });
        }

        let currentChallenge = null;
        for (const challengeItem of challenge.challenges) {
            const hasAccess = challengeItem.groups.some((group: { accessCode: string }) =>
                group.accessCode === agentProgress.currentProgress
            );
            if (hasAccess) {
                currentChallenge = challengeItem;
                break;
            }
        }

        if (!currentChallenge) {
            return res.status(400).json({
                success: false,
                message: "Aucune √©nigme active trouv√©e pour cet agent"
            });
        }

        const normalizedAnswer = answer.toLowerCase().trim();
        const normalizedExpected = currentChallenge.expectedOutput.toLowerCase().trim();
        const isCorrect = normalizedAnswer === normalizedExpected;

        if (isCorrect) {
            for (const frag of currentChallenge.fragmentId) {
                if (!agentProgress.unlockedFragments.includes(frag)) {
                    agentProgress.unlockedFragments.push(frag);
                }
            }

            agentProgress.lastUpdated = new Date();

            const totalFragments = challenge.challenges.flatMap((c: any) => c.fragmentId);
            const hasAllFragments = totalFragments.every((frag: string) =>
                agentProgress.unlockedFragments.includes(frag)
            );

            if (hasAllFragments) {
                agentProgress.complete = true;
                challenge.isComplete = true;
                challenge.isCompleteBy = agentBungieId;
            }

            await challenge.save();

            const agent = await Agent.findOne({ bungieId: agentBungieId });

            const rewardId = challenge.rewardId || `UNASSIGNED-${challenge.challengeId}`;

            if (agent) {
                const agentChallenge = agent.challenges.find(
                    (c: any) => c.challengeId === challenge.challengeId
                );

                if (agentChallenge) {
                    // Trouver l'embl√®me correspondant (selon le rewardId du challenge)
                    const targetEmblem = agentChallenge.emblems.find(
                        (e: any) => e.emblemId === challenge.rewardId
                    );

                    // Si pas encore dans le challenge ‚Üí on le cr√©e
                    if (!targetEmblem) {
                        agentChallenge.emblems.push({
                            emblemId: rewardId,
                            totalFragments: challenge.challenges.length * 3,
                            unlockedFragments: [...currentChallenge.fragmentId],
                            isComplete: hasAllFragments,
                            completedAt: hasAllFragments ? new Date() : undefined
                        });
                    } else {
                        for (const frag of currentChallenge.fragmentId) {
                            if (!targetEmblem.unlockedFragments.includes(frag)) {
                                targetEmblem.unlockedFragments.push(frag);
                            }
                        }
                        if (
                            targetEmblem.unlockedFragments.length >= targetEmblem.totalFragments &&
                            !targetEmblem.isComplete
                        ) {
                            targetEmblem.isComplete = true;
                            targetEmblem.completedAt = new Date();
                        }
                    }

                    agentChallenge.lastUpdatedAt = new Date();
                } else {
                    agent.challenges.push({
                        challengeMongoId: challenge._id,
                        challengeId: challenge.challengeId,
                        title: challenge.title,
                        emblems: [
                            {
                                emblemId: rewardId,
                                totalFragments: challenge.challenges.length * 3,
                                unlockedFragments: [...currentChallenge.fragmentId],
                                isComplete: hasAllFragments,
                                completedAt: hasAllFragments ? new Date() : undefined
                            }
                        ]
                    });
                }

                agent.lastActivity = new Date();
                await agent.save();

                await agentStatsService.syncAgentStats(agent._id.toString());
            }
            const fragmentsData = getFragmentsData(currentChallenge.fragmentId, challenge.finalCode);

            return res.status(200).json({
                success: true,
                message: hasAllFragments
                    ? "F√©licitations ! Vous avez compl√©t√© tout le challenge !"
                    : "R√©ponse correcte ! Fragment d√©bloqu√©.",
                data: {
                    fragments: currentChallenge.fragmentId,
                    fragmentsData,
                    unlockedFragments: agentProgress.unlockedFragments,
                    isComplete: agentProgress.complete,
                    totalFragments: agentProgress.unlockedFragments.length,
                    maxFragments: totalFragments.length,
                    ...(hasAllFragments && {
                        congratulations: "Challenge compl√©t√© avec succ√®s !",
                        completedBy: agentBungieId
                    })
                }
            });
        } else {
            return res.status(400).json({
                success: false,
                message: "R√©ponse incorrecte",
            });
        }

    } catch (error: any) {
        console.error("Erreur lors de la soumission de la r√©ponse:", error);
        return res.status(500).json({
            success: false,
            message: "Erreur serveur lors de la soumission",
            error: process.env.NODE_ENV === 'development' ? error.message : undefined
        });
    }
};
export const getAgentProgress = async (req: Request, res: Response) => {
    try {
        const agentBungieId = req.user?.bungieId;
        if (!agentBungieId) {
            return res.status(401).json({
                success: false,
                message: "Agent non authentifi√©"
            });
        }

        const challenges = await ChallengeModel.find({ "AgentProgress.bungieId": agentBungieId }).select('challengeId title description AgentProgress finalCode isComplete isCompleteBy isActive');

        const agentChallenges = challenges.map(challenge => {
            const agentProgress = challenge.AgentProgress.find((agent: any) =>
                agent.bungieId === agentBungieId
            );

            const partialCode = getPartialCode(agentProgress.unlockedFragments, challenge.finalCode);

            return {
                challengeId: challenge.challengeId,
                title: challenge.title,
                description: challenge.description,
                progress: agentProgress,
                partialCode,
                isComplete: challenge.isComplete,
                isCompleteBy: challenge.isCompleteBy,
                isActive: challenge.isActive
            };
        });

        const stats = {
            total: challenges.length,
            completed: agentChallenges.filter(c => c.isComplete).length,
            inProgress: agentChallenges.filter(c => !c.isComplete).length,
            totalFragments: agentChallenges.reduce((sum, c) =>
                sum + (c.progress.unlockedFragments?.length || 0), 0
            )
        };

        return res.status(200).json({
            success: true,
            stats,
            data: agentChallenges
        });
    } catch (error: any) {
        console.error("Erreur lors de la r√©cup√©ration du progr√®s:", error);
        return res.status(500).json({
            success: false,
            message: "Erreur serveur lors de la r√©cup√©ration du progr√®s",
            error: process.env.NODE_ENV === 'development' ? error.message : undefined
        });
    }
};

export const getAgentChallengeFragments = async (req: Request, res: Response) => {
    try {
        const { challengeId } = req.params;
        const agentBungieId = req.user?.bungieId;

        if (!challengeId) {
            return res.status(400).json({ message: "challengeId requis" });
        }
        if (!agentBungieId) {
            return res.status(401).json({ message: "Agent non authentifi√©" });
        }

        const challenge = await ChallengeModel.findOne({ challengeId });
        if (!challenge) {
            return res.status(404).json({ message: "Challenge non trouv√©" });
        }

        const agentProgress = challenge.AgentProgress.find((agent: any) =>
            agent.bungieId === agentBungieId
        );
        if (!agentProgress) {
            return res.status(404).json({ message: "Progression non trouv√©e pour cet agent" });
        }

        const fragmentsData = getFragmentsData(agentProgress.unlockedFragments, challenge.finalCode);

        return res.status(200).json({
            success: true,
            challengeId,
            unlockedFragments: agentProgress.unlockedFragments,
            fragmentsData,
            isComplete: challenge.isComplete,
            isCompleteBy: challenge.isCompleteBy,
            isActive: challenge.isActive
        });
    } catch (error: any) {
        return res.status(500).json({
            success: false,
            message: "Erreur serveur lors de la r√©cup√©ration des fragments",
            error: error.message
        });
    }
};