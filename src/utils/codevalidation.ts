import { generateUniqueId } from "./generate";

export interface ValidationResult {
    isValid: boolean;
    message?: string;
}

export interface ICodeFragment {
    A1: string;
    A2: string;
    A3: string;
}

export interface IBCodeFragment {
    B1: string;
    B2: string;
    B3: string;
}

export interface ICCodeFragment {
    C1: string;
    C2: string;
    C3: string;
}

export interface IDCodeFragment {
    D1: string;
    D2: string;
    D3: string;
}

export interface IFinalCode {
    AAA: ICodeFragment;
    BBB: IBCodeFragment;
    CCC: ICCodeFragment;
    DDD?: IDCodeFragment;
}

export const validateTargetCode = (code: string): ValidationResult => {
    if (!code || typeof code !== 'string') {
        return {
            isValid: false,
            message: "the code can't be empty"
        };
    }

    const codePattern3 = /^[A-Z0-9]{3}-[A-Z0-9]{3}-[A-Z0-9]{3}$/;
    const codePattern4 = /^[A-Z0-9]{3}-[A-Z0-9]{3}-[A-Z0-9]{3}-[A-Z0-9]{3}$/;

    if (!codePattern3.test(code) && !codePattern4.test(code)) {
        return {
            isValid: false,
            message: "the code must be in the format AAA-BBB-CCC or AAA-BBB-CCC-DDD."
        };
    }

    return {
        isValid: true
    };
};

export const splitTargetCodeToFinalCode = (targetCode: string): IFinalCode => {
    const validation = validateTargetCode(targetCode);
    if (!validation.isValid) {
        throw new Error(`Invalid code: ${validation.message}`);
    }

    const segments = targetCode.split('-');
    const [aaa, bbb, ccc, ddd] = segments;

    const finalCode: IFinalCode = {
        AAA: { A1: aaa[0], A2: aaa[1], A3: aaa[2] },
        BBB: { B1: bbb[0], B2: bbb[1], B3: bbb[2] },
        CCC: { C1: ccc[0], C2: ccc[1], C3: ccc[2] }
    };

    if (ddd) {
        finalCode.DDD = { D1: ddd[0], D2: ddd[1], D3: ddd[2] };
    }

    return finalCode;
};

export const buildTargetCodeFromFinalCode = (finalCode: IFinalCode): string => {
    const aaa = finalCode.AAA.A1 + finalCode.AAA.A2 + finalCode.AAA.A3;
    const bbb = finalCode.BBB.B1 + finalCode.BBB.B2 + finalCode.BBB.B3;
    const ccc = finalCode.CCC.C1 + finalCode.CCC.C2 + finalCode.CCC.C3;

    if (finalCode.DDD) {
        const ddd = finalCode.DDD.D1 + finalCode.DDD.D2 + finalCode.DDD.D3;
        return `${aaa}-${bbb}-${ccc}-${ddd}`;
    }

    return `${aaa}-${bbb}-${ccc}`;
};

export const validateCodeFormat = (format: string): ValidationResult => {
    if (!format || typeof format !== 'string') {
        return {
            isValid: false,
            message: "the format can't be empty."
        };
    }

    const formatPattern3 = /^[A-Z]{3}-[A-Z]{3}-[A-Z]{3}$/;
    const formatPattern4 = /^[A-Z]{3}-[A-Z]{3}-[A-Z]{3}-[A-Z]{3}$/;

    if (!formatPattern3.test(format) && !formatPattern4.test(format)) {
        return {
            isValid: false,
            message: "the codeFormat must be in the format XXX-XXX-XXX or XXX-XXX-XXX-XXX."
        };
    }

    return {
        isValid: true
    };
};

export const validateAccessCode = (accessCode: string): ValidationResult => {
    if (!accessCode || typeof accessCode !== 'string') {
        return {
            isValid: false,
            message: "the access code can't be empty."
        };
    }

    const accessCodePattern = /^[A-Za-z0-9_-]{3,50}$/;

    if (!accessCodePattern.test(accessCode)) {
        return {
            isValid: false,
            message: "the access code must contain between 3 and 50 characters (letters, numbers, dashes and underscores are allowed)."
        };
    }

    return {
        isValid: true
    };
};

export const codeMatchesFormat = (code: string, format: string): boolean => {
    if (!code || !format) return false;
    return code.length === format.length &&
        code.split('-').length === format.split('-').length;
};

export function determineFinalCode(autoGenerated: any, provided: any): IFinalCode {
    if (autoGenerated) return autoGenerated;
    if (provided) return provided;

    return {
        AAA: { A1: "", A2: "", A3: "" },
        BBB: { B1: "", B2: "", B3: "" },
        CCC: { C1: "", C2: "", C3: "" }
    };
}

export function validateAndProcessEntries(entries: any[]): string | null {
    for (let i = 0; i < entries.length; i++) {
        const entry = entries[i];

        if (!entry.name) {
            return `Entry ${i + 1}: name is required.`;
        }

        if (!entry.accessCode) {
            return `Entry ${i + 1}: accessCode is required.`;
        }

        const accessCodeValidation = validateAccessCode(entry.accessCode);
        if (!accessCodeValidation.isValid) {
            return `Entry ${i + 1}: ${accessCodeValidation.message}`;
        }

        if (!entry.entryId) {
            entry.entryId = generateUniqueId('ENTRY');
        }

        if (entry.subEntries && entry.subEntries.length > 0) {
            const subError = validateAndProcessEntries(entry.subEntries);
            if (subError) {
                return `Entry ${i + 1} > ${subError}`;
            }
        }
    }
    return null;
}

export function getPartialCode(unlockedFragments: string[], finalCode: any, format: "AAA-BBB-CCC" | "AAA-BBB-CCC-DDD" = "AAA-BBB-CCC"): string {
    const sections = format === "AAA-BBB-CCC-DDD"
        ? ['AAA', 'BBB', 'CCC', 'DDD']
        : ['AAA', 'BBB', 'CCC'];

    const codeParts = format === "AAA-BBB-CCC-DDD"
        ? [['A1', 'A2', 'A3'], ['B1', 'B2', 'B3'], ['C1', 'C2', 'C3'], ['D1', 'D2', 'D3']]
        : [['A1', 'A2', 'A3'], ['B1', 'B2', 'B3'], ['C1', 'C2', 'C3']];

    return codeParts.map((fragments, i) => {
        return fragments.map(frag => {
            if (unlockedFragments.includes(frag)) {
                return finalCode?.[sections[i]]?.[frag] || 'X';
            }
            return 'X';
        }).join('');
    }).join('-');
}

export function getFragmentData(fragmentId: string, finalCode: any): string | null {
    if (finalCode.AAA && finalCode.AAA[fragmentId]) return finalCode.AAA[fragmentId];
    if (finalCode.BBB && finalCode.BBB[fragmentId]) return finalCode.BBB[fragmentId];
    if (finalCode.CCC && finalCode.CCC[fragmentId]) return finalCode.CCC[fragmentId];
    if (finalCode.DDD && finalCode.DDD[fragmentId]) return finalCode.DDD[fragmentId];
    return null;
}

export function getFragmentsData(fragmentIds: string[], finalCode: any): (string | null)[] {
    return fragmentIds.map(frag => getFragmentData(frag, finalCode));
}

export function isSectionComplete(section: 'AAA' | 'BBB' | 'CCC' | 'DDD', unlockedFragments: string[]): boolean {
    const sectionFragments: Record<string, string[]> = {
        'AAA': ['A1', 'A2', 'A3'],
        'BBB': ['B1', 'B2', 'B3'],
        'CCC': ['C1', 'C2', 'C3'],
        'DDD': ['D1', 'D2', 'D3']
    };

    return sectionFragments[section].every(frag => unlockedFragments.includes(frag));
}

export function calculateCompletionPercentage(unlockedFragments: string[], format: "AAA-BBB-CCC" | "AAA-BBB-CCC-DDD" = "AAA-BBB-CCC"): number {
    const totalFragments = format === "AAA-BBB-CCC-DDD" ? 12 : 9;
    return Math.round((unlockedFragments.length / totalFragments) * 100);
}