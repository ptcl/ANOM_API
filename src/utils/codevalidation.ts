import { IFinalCode, ValidationResult } from "../types/challenge";
import { generateUniqueId } from "./generate";

export const validateTargetCode = (code: string): ValidationResult => {
    if (!code || typeof code !== 'string') {
        return {
            isValid: false,
            message: "Le code ne peut pas être vide."
        };
    }

    const codePattern = /^[A-Z0-9]{3}-[A-Z0-9]{3}-[A-Z0-9]{3}$/;

    if (!codePattern.test(code)) {
        return {
            isValid: false,
            message: "Le targetCode doit être au format AAA-BBB-CCC (lettres majuscules uniquement avec tirets)."
        };
    }

    return {
        isValid: true
    };
};

export const splitTargetCodeToFinalCode = (targetCode: string): IFinalCode => {
    const validation = validateTargetCode(targetCode);
    if (!validation.isValid) {
        throw new Error(`Code invalide: ${validation.message}`);
    }

    const segments = targetCode.split('-');
    const [aaa, bbb, ccc] = segments;

    return {
        AAA: {
            A1: aaa[0], // Premier caractère de AAA
            A2: aaa[1], // Deuxième caractère de AAA
            A3: aaa[2]  // Troisième caractère de AAA
        },
        BBB: {
            B1: bbb[0], // Premier caractère de BBB
            B2: bbb[1], // Deuxième caractère de BBB
            B3: bbb[2]  // Troisième caractère de BBB
        },
        CCC: {
            C1: ccc[0], // Premier caractère de CCC
            C2: ccc[1], // Deuxième caractère de CCC
            C3: ccc[2]  // Troisième caractère de CCC
        }
    };
};

export const buildTargetCodeFromFinalCode = (finalCode: IFinalCode): string => {
    const aaa = finalCode.AAA.A1 + finalCode.AAA.A2 + finalCode.AAA.A3;
    const bbb = finalCode.BBB.B1 + finalCode.BBB.B2 + finalCode.BBB.B3;
    const ccc = finalCode.CCC.C1 + finalCode.CCC.C2 + finalCode.CCC.C3;

    return `${aaa}-${bbb}-${ccc}`;
};

export const validateCodeFormat = (format: string): ValidationResult => {
    if (!format || typeof format !== 'string') {
        return {
            isValid: false,
            message: "Le format ne peut pas être vide."
        };
    }

    const formatPattern = /^[A-Z]{3}-[A-Z]{3}-[A-Z]{3}$/;

    if (!formatPattern.test(format)) {
        return {
            isValid: false,
            message: "Le codeFormat doit être au format XXX-XXX-XXX."
        };
    }

    return {
        isValid: true
    };
};

export const validateAccessCode = (accessCode: string): ValidationResult => {
    if (!accessCode || typeof accessCode !== 'string') {
        return {
            isValid: false,
            message: "Le code d'accès ne peut pas être vide."
        };
    }
    const accessCodePattern = /^[A-Za-z0-9_-]{3,20}$/;

    if (!accessCodePattern.test(accessCode)) {
        return {
            isValid: false,
            message: "Le code d'accès doit contenir entre 3 et 20 caractères (lettres, chiffres, tirets et underscores autorisés)."
        };
    }

    return {
        isValid: true
    };
};

export const codeMatchesFormat = (code: string, format: string): boolean => {
    if (!code || !format) return false;
    return code.length === format.length &&
        code.split('-').length === format.split('-').length;
};

export function determineFinalCode(autoGenerated: any, provided: any) {
    if (autoGenerated) return autoGenerated;
    if (provided) return provided;

    return {
        AAA: { A1: "", A2: "", A3: "" },
        BBB: { B1: "", B2: "", B3: "" },
        CCC: { C1: "", C2: "", C3: "" }
    };
}

export function validateAndProcessChallenges(challenges: any[]): string | null {
    for (let i = 0; i < challenges.length; i++) {
        const challenge = challenges[i];

        if (!challenge.challengeType || !challenge.expectedOutput) {
            return `Challenge ${i + 1}: challengeType et expectedOutput sont requis.`;
        }

        challenge.rewardId = generateUniqueId('REWARDID');

        if (!challenge.groups?.length) {
            return `Challenge ${i + 1}: au moins un groupe est requis.`;
        }

        for (let j = 0; j < challenge.groups.length; j++) {
            const group = challenge.groups[j];

            if (!group.accessCode || !group.promptLines?.length) {
                return `Challenge ${i + 1}, Groupe ${j + 1}: accessCode et promptLines sont requis.`;
            }

            const accessCodeValidation = validateAccessCode(group.accessCode);
            if (!accessCodeValidation.isValid) {
                return `Challenge ${i + 1}, Groupe ${j + 1}: ${accessCodeValidation.message}`;
            }
        }
    }
    return null;
}

export function getPartialCode(unlockedFragments: string[], finalCode: any): string {
    const codeParts = [
        ['A1', 'A2', 'A3'],
        ['B1', 'B2', 'B3'],
        ['C1', 'C2', 'C3']
    ];
    const sections = ['AAA', 'BBB', 'CCC'];
    return codeParts.map((fragments, i) => {
        return fragments.map(frag => {
            if (unlockedFragments.includes(frag)) {
                return finalCode?.[sections[i]]?.[frag] || 'X';
            }
            return 'X';
        }).join('');
    }).join('-');
}
// export function getFragmentsData(fragmentIds: string[], finalCode: any): string[] {
//     const result: string[] = [];
//     for (const frag of fragmentIds) {
//         if (finalCode.AAA && finalCode.AAA[frag]) result.push(finalCode.AAA[frag]);
//         else if (finalCode.BBB && finalCode.BBB[frag]) result.push(finalCode.BBB[frag]);
//         else if (finalCode.CCC && finalCode.CCC[frag]) result.push(finalCode.CCC[frag]);
//         else result.push("");
//     }
//     return result;
// }

export function getFragmentData(fragmentId: string, finalCode: any): string | null {
    if (finalCode.AAA && finalCode.AAA[fragmentId]) return finalCode.AAA[fragmentId];
    if (finalCode.BBB && finalCode.BBB[fragmentId]) return finalCode.BBB[fragmentId];
    if (finalCode.CCC && finalCode.CCC[fragmentId]) return finalCode.CCC[fragmentId];
    return null;
}


export function getFragmentsData(fragmentIds: string[], finalCode: any): (string | null)[] {
    return fragmentIds.map(frag => getFragmentData(frag, finalCode));
}